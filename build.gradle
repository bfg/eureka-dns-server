//
// build.gradle
//

buildscript {
  ext {
    lombokVersion             = "1.18.6"
    slf4jVersion              = "1.7.25"
    logbackVersion            = "1.2.3"

    groovyVersion             = "2.5.6"
    spockVersion              = "1.2-groovy-2.5"

    nettyVersion              = "4.1.34.Final"
    springBootVersion         = "1.5.19.RELEASE"
    springCloudVersion        = "Edgware.SR5"

    jdkByteCodeVersion        = "1.8"
  }
}

plugins {
  id "java-library"
  id "net.researchgate.release"             version "2.8.0"
  id "io.spring.dependency-management"      version "1.0.6.RELEASE"
  id "com.adarshr.test-logger"              version "1.6.0"
}

ext.isReleaseVersion = !version.contains("-SNAPSHOT")
def getProjectProp(name, defaultValue) {
  if (project.hasProperty(name)) {
    return project.getProperties().get(name)
  }

  // consult env vars
  def envVarName = name.toUpperCase().replace(".", "_")
  def envVarValue = System.getenv(envVarName)
  return (envVarValue) ? envVarValue : defaultValue
}

allprojects {
  apply plugin: "java"
  apply plugin: "java-library"
  apply plugin: "groovy"
  apply plugin: "idea"
  apply plugin: "eclipse"
  apply plugin: "maven"
  apply plugin: "maven-publish"
  apply plugin: "signing"
  apply plugin: "io.spring.dependency-management"
  apply plugin: "com.adarshr.test-logger"

  repositories {
    mavenLocal()
    mavenCentral()
  }

  dependencyManagement {
    imports {
      mavenBom  "io.netty:netty-bom:${nettyVersion}"
      mavenBom  "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
      mavenBom  "org.springframework.boot:spring-boot-dependencies:${springBootVersion}"
      mavenBom  "org.spockframework:spock-bom:${spockVersion}"
    }

    dependencies {
      dependency  "org.projectlombok:lombok:${lombokVersion}"
      dependency  "org.codehaus.groovy:groovy-all:${groovyVersion}"

      // logging
      dependency  "org.slf4j:slf4j-api:${slf4jVersion}"
      dependency  "org.slf4j:jcl-over-slf4j:${slf4jVersion}"

      dependency  "ch.qos.logback:logback-classic:${logbackVersion}"

      dependency  "org.springframework.boot:spring-boot-starter-test:${springBootVersion}"
    }
  }

  // dependencies for all projects
  dependencies {
    annotationProcessor     "org.projectlombok:lombok"
    compileOnly             "org.projectlombok:lombok"

    // JDK11 compilation compatibility
    compileOnly             "javax.annotation:javax.annotation-api:1.3.2"

    testAnnotationProcessor "org.projectlombok:lombok"
    testImplementation      "org.codehaus.groovy:groovy-all"
    testImplementation      "org.spockframework:spock-core"
    testImplementation      "ch.qos.logback:logback-classic"
  }


  plugins.withType(JavaPlugin) {
    // java bytecode version
    sourceCompatibility = "${jdkByteCodeVersion}"
    targetCompatibility = "${jdkByteCodeVersion}"

    // create jar only if there is something to package
    boolean hasSources = !sourceSets.main.allSource.files.isEmpty()
    jar {
      onlyIf { hasSources }
    }

    // create sources jar
    task sourcesJar(type: Jar, dependsOn: classes, overwrite: false) {
      classifier = "sources"
      from sourceSets.main.allJava
    }

    // javadoc options
    javadoc {
      options.encoding "UTF-8"
      options.addStringOption("Xdoclint:none", "-quiet")

      if(JavaVersion.current().isJava9Compatible()) {
        options.addBooleanOption('html5', true)
      }
    }

    task javadocJar(type: Jar, dependsOn: [classes, javadoc], overwrite: false) {
      from javadoc
      classifier = "javadoc"
    }

    // add compileOnly dependencies to test runtime classpath as well.
    sourceSets {
      test.compileClasspath += configurations.compileOnly
      test.runtimeClasspath += configurations.compileOnly
    }

    // set publish repos only if there are any sources to publish
    if (hasSources) {

      publishing {
        repositories {
          maven {
            def urlReleases   = "https://oss.sonatype.org/content/repositories/snapshots/"
            def urlSnapshots  = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"

            url = isReleaseVersion ? urlSnapshots : urlReleases
            credentials {
              username getProjectProp('osshr.user', 'some-osshr-user')
              password getProjectProp('osshr.pass', 'some-osshr-pass')
            }
          }
        }

        publications {
          mavenJava(MavenPublication) {
            from components.java

            if (tasks.findByName("sourcesJar")) {
              artifact sourcesJar
            }
            if (tasks.findByName("javadocJar")) {
              artifact javadocJar
            }

            pom {
              name        = "Eureka DNS server"
              description = "DNS server interface to Eureka service registry"
              url         = "https://github.com/bfg/eureka-dns-server/"

              scm {
                connection          = "scm:git:https://github.com/bfg/eureka-dns-server.git"
                developerConnection = "scm:git:https://github.com/bfg/eureka-dns-server.git"
                url                 = "https://github.com/bfg/eureka-dns-server/"
              }

              licenses {
                license {
                  name  = "The Apache License, Version 2.0"
                  url   = "http://www.apache.org/licenses/LICENSE-2.0.txt"
                }
              }

              developers {
                developer {
                  id    = "bfg"
                  name  = "Brane F. Graƒçnar"
                }
                developer {
                  id    = "github"
                  name  = "Github project contributors"
                  url   = "https://github.com/bfg/eureka-dns-server/graphs/contributors"
                }
              }
            }
          }
        }
      }
    }
  }

  artifacts {
    archives jar
    archives sourcesJar
    archives javadocJar
  }

  signing {
    // fetch signing key from gpg-agent
    // NOTE: don't forget to set gpg key id in `signing.gnupg.keyName` gradle property (~/.gradle.properties)
    useGpgCmd()

    // define what to sign
    //sign configurations.archives
    sign publishing.publications
  }

  tasks.withType(Sign) {
    // only do gpg sign if there is key defined and this is a release build
    onlyIf {
      isReleaseVersion &&
      project.hasProperty('signing.gnupg.keyName') &&
      gradle.taskGraph.hasTask("publish")
    }
  }

  tasks.withType(JavaCompile) {
    sourceCompatibility   = targetCompatibility = "${jdkByteCodeVersion}"
    options.incremental   = true
    //options.verbose       = true
    options.compilerArgs  << "-Xlint:deprecation" << "-Xlint:unchecked"
  }

  tasks.withType(GroovyCompile) {
    sourceCompatibility   = targetCompatibility = "${jdkByteCodeVersion}"
    options.incremental   = true
    //options.verbose       = true
    options.compilerArgs  << "-Xlint:deprecation" << "-Xlint:unchecked"
  }

  // required for successful spock test runtime execution
  ext['groovy.version'] = "${groovyVersion}"

  // reproducible builds
  tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps  = false
    reproducibleFileOrder   = true
  }

  testlogger {
    theme         "mocha"
    slowThreshold 5000
  }
}

subprojects {
  apply plugin: "jacoco"

  // BEGIN: jacoco test coverage
  task copyJacocoReports(type: Copy, dependsOn: "jacocoTestReport") {
    from "build/reports/jacoco/html"
    into "$rootDir/build/reports/jacoco/${project.name}"
  }

  jacoco {
    toolVersion = "0.8.3"
  }

  jacocoTestReport {
    reports {
      xml.enabled true
      csv.enabled false
      html.destination file("${buildDir}/reports/jacoco/html")
    }
  }

  test.finalizedBy copyJacocoReports
  // END: jacoco

  testResultsDirName = "$rootDir/build/junit"
  reporting.baseDir = "$rootDir/build/html/${project.name}"
}

test {
  failFast = true
}

release {
  git {
    requireBranch = ""
  }
}

// vim:shiftwidth=2 softtabstop=2 expandtab
// EOF
